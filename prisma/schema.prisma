// BizArch ERP - Database Schema
// Prisma 7.x with PostgreSQL on Neon

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ==================== AUTH ====================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String
  role          String    @default("user") // admin, user
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  customerAssignments CustomerAssignment[]

  @@map("users")
}

// ==================== PRODUCTS ====================

model Product {
  id          String        @id @default(cuid())
  name        String
  description String?
  price       Decimal       @db.Decimal(10, 2)  // Selling price
  cost        Decimal       @default(0) @db.Decimal(10, 2)  // Default cost when no lot available
  unit        String        @default("pcs") // pcs, kg, ltr, box, etc.
  sku         String?       @unique
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  invoiceItems         InvoiceItem[]
  purchaseInvoiceItems PurchaseInvoiceItem[]
  stockLots            StockLot[]
  openingStocks        OpeningStock[]
  quotationItems       QuotationItem[]

  @@map("products")
}

// ==================== CUSTOMERS ====================

model Customer {
  id          String    @id @default(cuid())
  name        String
  email       String?
  phone       String?
  address     String?
  city        String?
  state       String?
  zipCode     String?
  country     String?   @default("India")
  balance     Decimal   @default(0) @db.Decimal(12, 2) // Outstanding balance (Accounts Receivable)
  notes       String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  invoices     Invoice[]
  payments     Payment[]
  transactions CustomerTransaction[]
  quotations   Quotation[]
  assignments  CustomerAssignment[]

  @@map("customers")
}

model CustomerAssignment {
  id         String   @id @default(cuid())
  customerId String
  userId     String
  assignedAt DateTime @default(now())

  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([customerId, userId])
  @@map("customer_assignments")
}

// ==================== SUPPLIERS ====================

model Supplier {
  id          String    @id @default(cuid())
  name        String
  email       String?
  phone       String?
  address     String?
  city        String?
  state       String?
  zipCode     String?
  country     String?   @default("India")
  balance     Decimal   @default(0) @db.Decimal(12, 2) // Outstanding balance (Accounts Payable)
  notes       String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  purchaseInvoices PurchaseInvoice[]
  payments         SupplierPayment[]

  @@map("suppliers")
}

// ==================== INVOICES (SALES) ====================

model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  customerId    String
  customer      Customer      @relation(fields: [customerId], references: [id])

  issueDate     DateTime      @default(now())
  dueDate       DateTime

  subtotal      Decimal       @db.Decimal(12, 2)
  taxRate       Decimal       @default(0) @db.Decimal(5, 2) // Percentage
  taxAmount     Decimal       @default(0) @db.Decimal(12, 2)
  total         Decimal       @db.Decimal(12, 2)
  amountPaid    Decimal       @default(0) @db.Decimal(12, 2)
  balanceDue    Decimal       @db.Decimal(12, 2)

  notes         String?
  terms         String?

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  items              InvoiceItem[]
  payments           Payment[]
  paymentAllocations PaymentAllocation[]
  quotation          Quotation?

  @@map("invoices")
}

model InvoiceItem {
  id          String   @id @default(cuid())
  invoiceId   String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  productId   String?
  product     Product? @relation(fields: [productId], references: [id])

  description String
  quantity    Decimal  @db.Decimal(10, 2)
  unitPrice   Decimal  @db.Decimal(10, 2)
  discount    Decimal  @default(0) @db.Decimal(5, 2) // Percentage discount (0-100)
  total       Decimal  @db.Decimal(12, 2)

  costOfGoodsSold Decimal @default(0) @db.Decimal(12, 2) // COGS calculated via FIFO

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  lotConsumptions StockLotConsumption[]

  @@map("invoice_items")
}

// ==================== QUOTATIONS ====================

model Quotation {
  id                 String          @id @default(cuid())
  quotationNumber    String          @unique
  customerId         String
  customer           Customer        @relation(fields: [customerId], references: [id])

  issueDate          DateTime        @default(now())
  validUntil         DateTime

  status             QuotationStatus @default(SENT)

  subtotal           Decimal         @db.Decimal(12, 2)
  taxRate            Decimal         @default(0) @db.Decimal(5, 2)
  taxAmount          Decimal         @default(0) @db.Decimal(12, 2)
  total              Decimal         @db.Decimal(12, 2)

  notes              String?
  terms              String?

  convertedInvoiceId String?         @unique
  convertedInvoice   Invoice?        @relation(fields: [convertedInvoiceId], references: [id])
  convertedAt        DateTime?

  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  items              QuotationItem[]

  @@map("quotations")
}

enum QuotationStatus {
  SENT
  CONVERTED
  CANCELLED
  EXPIRED
}

model QuotationItem {
  id          String    @id @default(cuid())
  quotationId String
  quotation   Quotation @relation(fields: [quotationId], references: [id], onDelete: Cascade)

  productId   String?
  product     Product?  @relation(fields: [productId], references: [id])

  description String
  quantity    Decimal   @db.Decimal(10, 2)
  unitPrice   Decimal   @db.Decimal(10, 2)
  discount    Decimal   @default(0) @db.Decimal(5, 2)
  total       Decimal   @db.Decimal(12, 2)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("quotation_items")
}

// ==================== PURCHASE INVOICES ====================

model PurchaseInvoice {
  id                    String                @id @default(cuid())
  purchaseInvoiceNumber String                @unique
  supplierId            String
  supplier              Supplier              @relation(fields: [supplierId], references: [id])

  invoiceDate           DateTime              @default(now()) // Date of purchase
  dueDate               DateTime
  supplierInvoiceRef    String?               // Supplier's invoice number

  status                PurchaseInvoiceStatus @default(DRAFT)

  subtotal              Decimal               @db.Decimal(12, 2)
  taxRate               Decimal               @default(0) @db.Decimal(5, 2)
  taxAmount             Decimal               @default(0) @db.Decimal(12, 2)
  total                 Decimal               @db.Decimal(12, 2)
  amountPaid            Decimal               @default(0) @db.Decimal(12, 2)
  balanceDue            Decimal               @db.Decimal(12, 2)

  notes                 String?

  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  items                 PurchaseInvoiceItem[]
  payments              SupplierPayment[]
  paymentAllocations    SupplierPaymentAllocation[]
  stockLots             StockLot[]

  @@map("purchase_invoices")
}

enum PurchaseInvoiceStatus {
  DRAFT
  RECEIVED
  PAID
  PARTIALLY_PAID
  CANCELLED
}

model PurchaseInvoiceItem {
  id                String          @id @default(cuid())
  purchaseInvoiceId String
  purchaseInvoice   PurchaseInvoice @relation(fields: [purchaseInvoiceId], references: [id], onDelete: Cascade)

  productId         String
  product           Product         @relation(fields: [productId], references: [id])

  description       String
  quantity          Decimal         @db.Decimal(10, 2)
  unitCost          Decimal         @db.Decimal(10, 2) // Purchase cost per unit
  discount          Decimal         @default(0) @db.Decimal(5, 2) // Percentage discount (0-100)
  total             Decimal         @db.Decimal(12, 2)

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  stockLot          StockLot?       // One-to-one: each purchase item creates one lot

  @@map("purchase_invoice_items")
}

// ==================== PAYMENTS (FROM CUSTOMERS) ====================

model Payment {
  id            String        @id @default(cuid())
  paymentNumber String        @unique

  customerId    String
  customer      Customer      @relation(fields: [customerId], references: [id])

  invoiceId     String?
  invoice       Invoice?      @relation(fields: [invoiceId], references: [id])

  amount        Decimal       @db.Decimal(12, 2)
  paymentDate   DateTime      @default(now())
  paymentMethod PaymentMethod @default(CASH)
  reference     String?       // Check number, transaction ID, etc.
  notes         String?

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  allocations   PaymentAllocation[]

  @@map("payments")
}

model PaymentAllocation {
  id        String   @id @default(cuid())
  paymentId String
  payment   Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  invoiceId String
  invoice   Invoice  @relation(fields: [invoiceId], references: [id])
  amount    Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())

  @@index([paymentId])
  @@index([invoiceId])
  @@map("payment_allocations")
}

// ==================== SUPPLIER PAYMENTS (TO SUPPLIERS) ====================

model SupplierPayment {
  id                String          @id @default(cuid())
  paymentNumber     String          @unique

  supplierId        String
  supplier          Supplier        @relation(fields: [supplierId], references: [id])

  purchaseInvoiceId String?
  purchaseInvoice   PurchaseInvoice? @relation(fields: [purchaseInvoiceId], references: [id])

  amount            Decimal         @db.Decimal(12, 2)
  paymentDate       DateTime        @default(now())
  paymentMethod     PaymentMethod   @default(CASH)
  reference         String?
  notes             String?

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  allocations       SupplierPaymentAllocation[]

  @@map("supplier_payments")
}

model SupplierPaymentAllocation {
  id                String          @id @default(cuid())
  supplierPaymentId String
  supplierPayment   SupplierPayment @relation(fields: [supplierPaymentId], references: [id], onDelete: Cascade)
  purchaseInvoiceId String
  purchaseInvoice   PurchaseInvoice @relation(fields: [purchaseInvoiceId], references: [id])
  amount            Decimal         @db.Decimal(12, 2)
  createdAt         DateTime        @default(now())

  @@index([supplierPaymentId])
  @@index([purchaseInvoiceId])
  @@map("supplier_payment_allocations")
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHECK
  CREDIT_CARD
  UPI
  OTHER
}

// ==================== INVENTORY / STOCK ====================

model StockLot {
  id                    String               @id @default(cuid())
  productId             String
  product               Product              @relation(fields: [productId], references: [id])

  sourceType            StockSourceType
  purchaseInvoiceItemId String?              @unique
  purchaseInvoiceItem   PurchaseInvoiceItem? @relation(fields: [purchaseInvoiceItemId], references: [id])
  purchaseInvoiceId     String?
  purchaseInvoice       PurchaseInvoice?     @relation(fields: [purchaseInvoiceId], references: [id])
  openingStockId        String?              @unique
  openingStock          OpeningStock?        @relation(fields: [openingStockId], references: [id])

  lotDate               DateTime             // Date for FIFO ordering
  unitCost              Decimal              @db.Decimal(10, 2) // Cost per unit for this lot
  initialQuantity       Decimal              @db.Decimal(10, 2) // Original quantity
  remainingQuantity     Decimal              @db.Decimal(10, 2) // Current available quantity

  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  consumptions          StockLotConsumption[]

  @@index([productId, lotDate])
  @@index([productId, remainingQuantity])
  @@map("stock_lots")
}

enum StockSourceType {
  PURCHASE
  OPENING_STOCK
  ADJUSTMENT
}

model StockLotConsumption {
  id               String      @id @default(cuid())
  stockLotId       String
  stockLot         StockLot    @relation(fields: [stockLotId], references: [id])

  invoiceItemId    String
  invoiceItem      InvoiceItem @relation(fields: [invoiceItemId], references: [id], onDelete: Cascade)

  quantityConsumed Decimal     @db.Decimal(10, 2)
  unitCost         Decimal     @db.Decimal(10, 2) // Cost at time of consumption
  totalCost        Decimal     @db.Decimal(12, 2)

  createdAt        DateTime    @default(now())

  @@index([stockLotId])
  @@index([invoiceItemId])
  @@map("stock_lot_consumptions")
}

model OpeningStock {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])

  quantity  Decimal  @db.Decimal(10, 2)
  unitCost  Decimal  @db.Decimal(10, 2)
  stockDate DateTime // Opening stock date for FIFO

  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stockLot  StockLot? // One-to-one relation to the created lot

  @@map("opening_stocks")
}

// ==================== CUSTOMER TRANSACTIONS (FOR STATEMENT) ====================

model CustomerTransaction {
  id              String                  @id @default(cuid())
  customerId      String
  customer        Customer                @relation(fields: [customerId], references: [id])

  transactionType CustomerTransactionType
  transactionDate DateTime
  amount          Decimal                 @db.Decimal(12, 2) // Positive for debit (invoice), negative for credit (payment)
  description     String

  invoiceId       String?
  paymentId       String?

  runningBalance  Decimal                 @db.Decimal(12, 2) // Balance after this transaction

  createdAt       DateTime                @default(now())

  @@index([customerId, transactionDate])
  @@map("customer_transactions")
}

enum CustomerTransactionType {
  OPENING_BALANCE
  INVOICE
  PAYMENT
  CREDIT_NOTE
  ADJUSTMENT
}

// ==================== SETTINGS ====================

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("settings")
}
